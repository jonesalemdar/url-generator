"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.staticPlugin = void 0;
const elysia_1 = require("elysia");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const node_cache_1 = __importDefault(require("node-cache"));
const cache_1 = require("./cache");
const statCache = new node_cache_1.default({
    useClones: false,
    checkperiod: 5 * 60,
    stdTTL: 3 * 60 * 60,
    maxKeys: 250
});
const fileCache = new node_cache_1.default({
    useClones: false,
    checkperiod: 5 * 60,
    stdTTL: 3 * 60 * 60,
    maxKeys: 250
});
const htmlCache = new node_cache_1.default({
    useClones: false,
    checkperiod: 5 * 60,
    stdTTL: 3 * 60 * 60,
    maxKeys: 250
});
const listFiles = async (dir) => {
    const files = await (0, promises_1.readdir)(dir);
    const all = await Promise.all(files.map(async (name) => {
        const file = dir + '/' + name;
        const stats = await (0, promises_1.stat)(file);
        return stats && stats.isDirectory()
            ? await listFiles(file)
            : [(0, path_1.resolve)(dir, file)];
    }));
    return all.flat();
};
const staticPlugin = async ({ assets = 'public', prefix = '/public', staticLimit = 1024, alwaysStatic = false, ignorePatterns = ['.DS_Store', '.git', '.env'], noExtension = false, enableDecodeURI = false, resolve = path_1.resolve, headers = {}, noCache = false, indexHTML = true } = {
    assets: 'public',
    prefix: '/public',
    staticLimit: 1024,
    alwaysStatic: process.env.NODE_ENV === 'production',
    ignorePatterns: [],
    noExtension: false,
    enableDecodeURI: false,
    resolve: path_1.resolve,
    headers: {},
    noCache: false,
    indexHTML: true
}) => {
    const files = await listFiles((0, path_1.resolve)(assets));
    if (prefix === '/')
        prefix = '';
    const shouldIgnore = (file) => {
        if (!ignorePatterns.length)
            return false;
        return ignorePatterns.find((pattern) => {
            if (typeof pattern === 'string')
                return pattern.includes(file);
            else
                return pattern.test(file);
        });
    };
    const app = new elysia_1.Elysia({
        name: 'static',
        seed: {
            assets,
            prefix,
            staticLimit,
            alwaysStatic,
            ignorePatterns,
            noExtension,
            resolve: resolve.toString(),
            headers,
            noCache,
            indexHTML
        }
    });
    if (alwaysStatic ||
        (process.env.ENV === 'production' && files.length <= staticLimit))
        for (let i = 0; i < files.length; i++) {
            const filePath = files[i];
            if (!filePath || shouldIgnore(filePath))
                continue;
            let fileName = filePath
                .replace(resolve(), '')
                .replace(`${assets}/`, '');
            if (noExtension) {
                const temp = fileName.split('.');
                temp.splice(-1);
                fileName = temp.join('.');
            }
            const file = Bun.file(filePath);
            const etag = await (0, cache_1.generateETag)(file);
            app.get((0, path_1.join)(prefix, fileName), noCache
                ? new Response(file, {
                    headers
                })
                : async ({ headers: reqHeaders }) => {
                    if (await (0, cache_1.isCached)(reqHeaders, etag, filePath)) {
                        return new Response(null, {
                            status: 304,
                            headers
                        });
                    }
                    headers['Etag'] = etag;
                    headers['Cache-Control'] = 'public, max-age=0';
                    return new Response(file, {
                        headers
                    });
                });
            if (indexHTML && fileName.endsWith('/index.html'))
                app.get((0, path_1.join)(prefix, fileName.replace('/index.html', '')), noCache
                    ? new Response(file, {
                        headers
                    })
                    : async ({ headers: reqHeaders }) => {
                        if (await (0, cache_1.isCached)(reqHeaders, etag, filePath)) {
                            return new Response(null, {
                                status: 304,
                                headers
                            });
                        }
                        headers['Etag'] = etag;
                        headers['Cache-Control'] = 'public, max-age=0';
                        return new Response(file, {
                            headers
                        });
                    });
        }
    else {
        if (!app.routes.find(({ method, path }) => path === `${prefix}/*` && method === 'GET'))
            app.onError(() => { }).get(`${prefix}/*`, async ({ params, headers: reqHeaders }) => {
                const path = enableDecodeURI
                    ? decodeURI(`${assets}/${decodeURI(params['*'])}`)
                    : `${assets}/${params['*']}`;
                if (shouldIgnore(path))
                    throw new elysia_1.NotFoundError();
                try {
                    let status = statCache.get(path);
                    if (!status) {
                        status = await (0, promises_1.stat)(path);
                        statCache.set(path, status);
                    }
                    let file = fileCache.get(path);
                    if (!file) {
                        if (status.isDirectory()) {
                            let hasCache = false;
                            if (indexHTML &&
                                (hasCache =
                                    htmlCache.get(`${path}/index.html`) ??
                                        (await (0, promises_1.exists)(`${path}/index.html`)))) {
                                if (hasCache === undefined)
                                    htmlCache.set(`${path}/index.html`, true);
                                file = Bun.file(`${path}/index.html`);
                            }
                            else {
                                if (indexHTML && hasCache === undefined)
                                    htmlCache.set(`${path}/index.html`, false);
                                throw new elysia_1.NotFoundError();
                            }
                        }
                        file ??= Bun.file(path);
                        fileCache.set(path, file);
                    }
                    if (noCache)
                        return new Response(file, {
                            headers
                        });
                    const etag = await (0, cache_1.generateETag)(file);
                    if (await (0, cache_1.isCached)(reqHeaders, etag, path))
                        return new Response(null, {
                            status: 304,
                            headers
                        });
                    headers['Etag'] = etag;
                    headers['Cache-Control'] = 'public, max-age=0';
                    return new Response(file, {
                        headers
                    });
                }
                catch (error) {
                    throw new elysia_1.NotFoundError();
                }
            });
    }
    return app;
};
exports.staticPlugin = staticPlugin;
exports.default = exports.staticPlugin;
